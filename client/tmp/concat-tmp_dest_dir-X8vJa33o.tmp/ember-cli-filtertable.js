eval("define(\"ember-cli-filtertable/components/action-button\", \n  [\"ember\",\"exports\"],\n  function(__dependency1__, __exports__) {\n    \"use strict\";\n    var Em = __dependency1__[\"default\"];\n\n    __exports__[\"default\"] = Em.Component.extend({\n      tagName: \'button\',\n      classNames: [\'btn\'],\n      classNameBindings: [\'selectedClass\'],\n      attributeBindings: [\'isDisabled:disabled\'],\n      isDisabled: function() {\n        return this.get(\'isButtonActive\') === false;\n      }.property(\'isButtonActive\'),\n      selectedClass: function() {\n        var c = (this.get(\'isButtonActive\') === true) ?\n               this.get(\'activeClass\') : \'btn-default\';\n        if (this.get(\'isSet\') === true) {\n          c += \' active\';\n        }\n        return c;\n      }.property(\'isButtonActive\', \'isSet\'),\n\n      /* User variables */\n      activeClass: \'btn-primary\',\n      isButtonActive: function() {\n        var key = this.get(\'buttonToggleName\');\n        return Em.isBlank(key) ? true : this.get(key);\n      }.property(\'targetObject.selectedRecords.@each\'),\n      buttonToggleName: function() {\n        if (Em.isBlank(this.get(\'isActive\'))) {\n          Em.debug(\"No isActive function for action button %@\".fmt(this.get(\'title\')));\n          return null;\n        }\n        var activeFn = \'targetObject.%@\'.fmt(this.get(\'isActive\'));\n        if (!Em.isBlank(this.get(activeFn))) {\n          return activeFn;\n        }\n        activeFn = \'targetObject.%@\'.fmt(activeFn);\n        // custom handler on controller\n        if (!Em.isBlank(this.get(activeFn))) {\n          return activeFn;\n        }\n        // no handler found\n        return null;\n      }.property(),\n      hasGlyph: function() {\n        return (!Em.isBlank(this.get(\'glyphicon\')));\n      }.property(\'glyphicon\'),\n      action: null,\n      click: function() {\n        if (Em.isBlank(this.get(\'action\'))) {\n          Em.debug(\"No action defined for \" + this.get(\'title\'));\n          alert(\"Not yet implemented\");\n          return;\n        }\n        // This component can lie either in the controller or in the filter table\n        // component. We assume its in the filter table, but if not, the controller\n        // is the relevant targetObject\n        var t = this.get(\'targetObject\');\n        t = (t.get(\'targetObject\') === undefined) ? t : t.get(\'targetObject\');\n        t.send(this.get(\'action\'));\n      }\n    });\n  });//# sourceURL=ember-cli-filtertable/components/action-button.js");

;eval("define(\"ember-cli-filtertable/components/filter-table\", \n  [\"ember\",\"exports\"],\n  function(__dependency1__, __exports__) {\n    \"use strict\";\n    var Em = __dependency1__[\"default\"];\n\n    __exports__[\"default\"] = Em.Component.extend({\n      /* System settings */\n      layoutName: \'components/filter-table\',\n      selectAll: false,  // select-all button off by default\n      deselectAll: false,  // toggle for deselecting all (w/o all being selected)\n      selectedRecords: Em.A([]),\n      updateSelectedRecords: function() {\n        var sr = this.get(\'selectedRecords\'),\n            fr = this.get(\'filteredRecords\');\n        Em.run.once(function() {\n          sr.clear();\n          sr.addObjects(fr.filterBy(\'selected\', true));\n          Em.debug(\"Selected: %@\".fmt(sr.get(\'length\')));\n        });\n      }.observes(\'filteredRecords.@each.selected\'),\n      loadSelectedRecordsOnController: function() {\n        var to = this.get(\'targetObject\');\n        if (to === undefined || to === null) {\n          Em.debug(\"WARNING: no target object found. Are we testing?\");\n          return;\n        }\n        if (Em.isBlank(to.get(\'selectedRecords\'))) {\n          this.set(\'targetObject.selectedRecords\', this.get(\'selectedRecords\'));\n        }\n      }.on(\'init\'),\n      isTree: false,\n      showSearchAncestors: true,\n\n      /* General table settings */\n      viewLimit: 20,\n      columnNum: 2,\n      headerFilterColspan: function() {\n        var diff = (this.get(\'showCheckboxes\')) ? 1 : 0;\n        return this.get(\'columnNum\') + diff;\n      }.property(\'columnNum\'),\n\n      /* Elements pertaining to the input box used for filtereing results */\n      showTextFilter: true,\n      textFilter: \"\",  // The search bar at the top for filtering\n      filterField: \'name\',\n\n      /* Checkbox select/deselect all logic */\n      showCheckboxes: true,\n      noneSelected: function() {\n        return this.get(\'selectedRecords.length\') < 1;\n      }.property(\'selectedRecords.@each\'),\n      oneSelected: function() {\n        return this.get(\'selectedRecords.length\') === 1;\n      }.property(\'selectedRecords.@each\'),\n      oneOrMoreSelected: function() {\n        return this.get(\'selectedRecords.length\') > 0;\n      }.property(\'selectedRecords.@each\'),\n      allSelected: function() {\n        return this.get(\'selectedRecords.length\') ===\n               this.get(\'filteredRecords.length\');\n      }.property(\'selectedRecords.@each\', \'filteredRecords.@each\'),\n\n      /* Tree view settings */\n      applyTreeFilter: function(records) {\n        /* All expand/collapse logic is done here. We don\'t dynamically add records\n         * in the template. Instead we add them to the list here and rely on the\n         * sorting by depth first to ensure the correct order.\n         */\n        if (this.get(\'isTree\') === false) {\n          return records;\n        }\n        function getSubtree(record) {\n          // Returns an array containing the whole subtree of the parent\n          var records = [record];\n          if (record.get(\'isExpanded\') === true) {\n            // This needs to become a promise for async references\n            record.get(\'children.content\').forEach(function(child) {\n              records = records.concat(getSubtree(child));\n            });\n          }\n          return records;\n        }\n        function isAncestor(node, filterResults) {\n          var _isAncestor = false;\n          node.get(\'children\').forEach(function(child) {\n            if (filterResults.indexOf(child) > -1) {\n              // this is a direct parent of a search result\n              _isAncestor = true;\n            }\n            if (isAncestor(child, filterResults) === true) {\n              // this child is a distant ancestor;\n              _isAncestor = true;\n            }\n          });\n          return _isAncestor;\n        }\n\n        function getAncestors(node, filterResults) {\n          var ancestors = [];\n\n\n          if (filterResults.indexOf(node) > -1) {\n            ancestors.push(node);\n          } else {\n            if (isAncestor(node, filterResults)) {\n              ancestors.push(node);\n              var childAncestors = [];\n              node.get(\'children\').forEach(function(child) {\n                childAncestors = childAncestors.concat( getAncestors(child, filterResults));\n              });\n              ancestors = ancestors.concat(childAncestors);\n            }\n          }\n          return ancestors;\n        }\n\n        var finalGroups = Em.A([]);\n        Em.debug(\"If text filter is empty, display root nodes\");\n        if (Em.isBlank(this.get(\'textFilter\'))) {\n          // work off the root nodes\n          records.forEach(function(r) {\n            if (r.get(\'depth\') < 2) {\n              finalGroups = finalGroups.concat(getSubtree(r));\n            }\n          });\n        } else {\n          if (this.get(\'showSearchAncestors\') === false) {\n            // show only matching search results\n            finalGroups = records;\n          } else {\n            // Construct a tree containing the ancestry lines of the matching\n            // search results. We do this by traversing the tree from all the roots\n            var roots = this.get(\'_prefilterRecords\').filterBy(\'depth\', 1);\n\n            Em.debug(\'- Getting ancestry -\');\n            roots.forEach(function(r) {\n              Em.debug(\'  %@\'.fmt(r.get(\'name\')));\n              finalGroups = finalGroups.concat(getAncestors(r, records));\n            });\n          }\n        }\n\n        return finalGroups;\n      },\n\n      filteredRecords: Em.A([]), // Displayed records\n      toggleAllSelection: function() {\n        // Called when selectAll checkbox is toggled and ensures all records\'\n        // selection status matches that decreed by the select-all button\n        var fRecords = this.get(\'filteredRecords\'),\n            sRecords = this.get(\'selectedRecords\'),\n            aRecords = this.get(\'content\').filterBy(\'selected\', true);\n        Em.debug(\"Select-all checkbox selected? %@\".fmt(this.get(\'selectAll\')));\n        Em.run.once(this, function() {\n          if (this.get(\'selectAll\') === true) {\n            // Select-all button checked, ensure that all visible records are\n            // selected, and invisible records are unchecked\n            if (sRecords.get(\'length\') === fRecords.get(\'length\')) {\n              // all records are already selected\n              return;\n            }\n            // unselecting hidden records, and select all visible records\n            aRecords.forEach(function(r) {\n              r.set(\'selected\', false);\n            });\n            fRecords.forEach(function(r) {\n              r.set(\'selected\', true);\n            });\n          } else {\n            // select-all is unchecked, so lets unselect all if all visible records\n            // are selected\n            if (sRecords.get(\'length\') === fRecords.get(\'length\')) {\n              // deselect-all since all are selected\n              aRecords.forEach(function(r) {\n                r.set(\'selected\', false);\n              });\n            }\n          }\n        });\n      }.observes(\'selectAll\'),\n      toggleSelectAllCheckbox: function() {\n        Em.run.once(this, function() {\n          var as = this.get(\'allSelected\'), sa = this.get(\'selectAll\');\n          if (as !== sa) {\n            Em.debug(\"Set select-all checkbox to table state\");\n            this.set(\'selectAll\', as);\n          }\n        });\n      }.observes(\'selectedRecords.@each\'),\n      deselectAllRecords: function() {\n        if (this.get(\'deselectAll\') !== true) {\n          // only run this when deselectAll is set to true. it is automatically\n          // returned to false once everything has been deselected;\n          return;\n        }\n        // Explicitly deselect all. Just setting selectAll to false isn\'t\n        // sufficient since not all records may be selected at this point\n        if (this.get(\'selectAll\') === true) {\n          // all records are selected, so we can simply deselect them all\n          this.set(\'selectAll\', false);\n        } else {\n          var aRecords = this.get(\'content\').filterBy(\'selected\', true);\n          aRecords.forEach(function(r) {\n            r.set(\'selected\', false);\n          });\n        }\n        this.set(\'deselectAll\', false);\n      }.observes(\'deselectAll\'),\n      hasNoFilteredRecords: function() {\n        return this.get(\'filteredRecords.length\') < 1;\n      }.property(\'filteredRecords.@each\'),\n      hasNoActualRecords: function() {\n        return this.get(\'content\').get(\'length\') < 1;\n      }.property(\'content.@each\'),\n      applyTextFilter: function(ac) {\n        var filter = this.get(\'textFilter\');\n        if (!Em.isBlank(filter)) {\n          Em.debug(\"Applying text filter to records\");\n          filter = filter.toLowerCase();\n          var ff = this.get(\'filterField\');\n          ac = ac.filter(function(record) {\n            if (Em.isBlank(record) || Em.isBlank(record.get(ff))) {\n              return false;\n            }\n            return record.get(ff).toLowerCase().indexOf(filter) > -1;\n          });\n        }\n        return ac;\n      },\n      loadRecords: function() {\n        Em.debug(\'Refreshing visible records\');\n        if (this.get(\'_ignoreReload\') === true) {\n          Em.debug(\"Don\'t reload for targetObject.reload value change\");\n          this.set(\'_ignoreReload\', false);\n          return;\n        }\n        if (this.get(\'reloadRecords\') === true) {\n          this.set(\'_ignoreReload\', true);\n          this.set(\'reloadRecords\', false);\n        }\n        var ac = this.get(\'arrangedContent\') ||\n                 this.get(\'content.arrangedContent\') ||\n                 this.get(\'content\');\n        if (Em.isEmpty(ac)) {\n          this.set(\'filteredRecords\', []);\n          return;\n        }\n        ac = ac.toArray();  // make copy of the content record\n        this.set(\'_prefilterRecords\', ac);\n        ac = this.applyTextFilter(ac);\n        if (!Em.isBlank(this.get(\'targetObject.applyDropdownFilter\'))) {\n          ac = this.get(\'targetObject\').applyDropdownFilter(ac);\n        }\n        if (ac.then === undefined) {\n          this.showFilteredRecords(ac);\n        } else {\n          var that = this;\n          ac.then(function(records) {\n            that.showFilteredRecords(records.get(\'content\') || records);\n          });\n        }\n      }.observes(\'textFilter\', \'reloadRecords\'),\n      showFilteredRecords: function(records) {\n        records = this.applyTreeFilter(records);\n        Em.debug(\"Showing filteredRecords\");\n        var vl = this.get(\'viewLimit\');\n        if (vl > 0 && records.get(\'length\') > this.get(\'viewLimit\')) {\n          Em.debug(\"\\tChopping records to viewLimit\");\n          records = records.splice(0, this.get(\'viewLimit\'));\n        }\n        this.set(\'filteredRecords\', Em.A(records));\n      },\n      loadOnContentChange: function() {\n        if (Em.isEmpty(this.get(\'content\'))) {\n          return;\n        }\n        Em.run.once(this, \'loadRecords\');\n      }.on(\'init\').observes(\'content.@each\'),\n      actions: {\n        // custom actions which the user can implement. Its a direct link to a\n        // controller action handler\n        submit: function(actionName, record) {\n          this.get(\'targetObject\').send(actionName, record);\n        },\n        remove: function(actionName, record) {\n          this.get(\'targetObject\').send(actionName, record);\n        },\n        toggleExpand: function(record) {\n          Em.debug(\"Expanding/Collapsing record\");\n          var e = record.get(\'isExpanded\') || false;\n          if (record.get(\'childNum\') < 1) {\n            Em.debug(\"Cannot expand record without children\");\n            return;\n          }\n          record.set(\'isExpanded\', !e);\n          this.set(\'reloadRecords\', true);\n        }\n      }\n    });\n  });//# sourceURL=ember-cli-filtertable/components/filter-table.js");

;eval("define(\"ember-cli-filtertable/helpers/tree-tab\", \n  [\"ember\",\"exports\"],\n  function(__dependency1__, __exports__) {\n    \"use strict\";\n    var Em = __dependency1__[\"default\"];\n\n    // Show the expand/contract arrow and tab the colum to the relevant depth\n    __exports__[\"default\"] = Em.Handlebars.makeBoundHelper(function(record) {\n      var txt = \'<span style=\"padding-left: %@em;\">%@</span>\',\n          indent = Math.max(0, record.get(\'depth\')-1 * 1.2),  // default indent is 1.2 em;\n          isExpanded = record.get(\'isExpanded\') || false;\n      if (record.get(\'childNum\') < 1) {\n        txt = txt.fmt(indent, \'- \');\n      } else if (isExpanded === true) {\n        txt = txt.fmt(indent, \'# \');\n      } else {\n        txt = txt.fmt(indent, \'+ \');\n      }\n      return new Em.Handlebars.SafeString(txt);\n    });\n  });//# sourceURL=ember-cli-filtertable/helpers/tree-tab.js");

;eval("define(\"ember-cli-filtertable\", [\"ember-cli-filtertable/index\",\"exports\"], function(__index__, __exports__) {\n  \"use strict\";\n  Object.keys(__index__).forEach(function(key){\n    __exports__[key] = __index__[key];\n  });\n});\n//# sourceURL=__reexport.js");
